% rebase('layout.tpl', title=title, year=year)

<!DOCTYPE html>
<html lang="en">


<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

<div class="petya-t">
    <img class="vector-4" src="/static/assets/vectors/vector_1_x2.svg" />
    <img class="vector-2" src="/static/assets/vectors/vector_2_x2.svg" />
    <img class="vector-3" src="/static/assets/vectors/vector_3_x2.svg" />
    <div class="rectangle-2">
        <span class="theory">
            {{ title }}
        </span>
        <title>{{ message }}</title>
        </head>
        <body>
            <h1 class="theory-seva-h1">{{ message }}</h1>

            <p><strong><h2 class="theory-seva-h2">§1. Постановка задачи линейного программирования.</h2><strong>

            <p class="theory-sevaT">Определение: Линейное программирование – математическая дисциплина, посвященная теории и методам решения экстремальных задач на множествах n- мерного пространства, задаваемых системами линейными уравнений и неравенств.</p>
            <p class="theory-sevaT">Общая задача линейного программирования (далее – ЛП) имеет вид: </p>

            <div class="image-container">
            <img src="/static/assets/images/1_1.png">
            </div>
            </p>


            <p><strong><h2 class="theory-seva-h2">§2. Каноническая форма задачи ЛП.</h2><strong>
            <p class="theory-sevaT">Каноническая форма задачи ЛП:</p>
            <div class="image-container">
            <img src="/static/assets/images/1_2.png">
            </div>
            <p class="theory-sevaT">Замечание: Любая задача ЛП сводится к канонической.</p>

            <p class="theory-sevaT">Алгоритм перехода от произвольной задачи ЛП к канонической форме:</p>

            <p class="theory-sevaT">Неравенства с отрицательными bᵢ умножаем на (-1).</p>
            <p class="theory-sevaT">Если неравенство вида (≤), то к левой части добавляем sᵢ – добавочную переменную, и получаем равенство.</p>
            <p class="theory-sevaT">Если неравенство вида (≥), то из левой части вычитаем sᵢ, и получаем равенство.</p>
            <p class="theory-sevaT">Делаем замену переменных:</p>

            <p class="theory-sevaT">Если xᵢ ≤ 0, то xᵢ'= -xᵢ ≥ 0</p>
            <p class="theory-sevaT">Если xᵢ — любой, то xᵢ= xᵢ' - xᵢ'', где xᵢ', xᵢ''≥ 0</p>

            <p class="theory-sevaT">Замечание: Будем нумеровать sᵢ по номеру неравенства, в которое мы его добавили.</p>

            <p class="theory-sevaT">Замечание: sᵢ ≥ 0.</p>
            </p>


            <p><strong><h2 class="theory-seva-h2">§3. Угловые точки. Базисные/свободные переменные. Базисные решения.</h2><strong>
            <p class="theory-sevaT">Определение: Точка Х ∈ D называется угловой точкой, если представление </p>

            <p class="theory-sevaT">X = aX¹ + (1-a)X², где X¹, X² ∈ D; 0 < a < 1 возможно только при Х¹ = Х²</p>

            <p class="theory-sevaT">Иными словами, невозможно найти две точки в области, интервал проходящий через которые содержит Х (т.е. Х – не внутренняя точка).</p>

            <p class="theory-sevaT">Графический способ решения задачи ЛП показывает, что нахождение оптимального решения ассоциируется с угловой точкой. Это является основной концепцией при разработке симплекс-метода.</h5>

            <p class="theory-sevaT">Определение: Пусть есть система m уравнений и n неизвестных (m < n). Разделим переменные на два множества: (n-m) переменные положим равными нулю, а остальные m переменных определяются решением системы исходных уравнений. Если это решение единственно, то тогда ненулевые m переменных называют базисными; нулевые (n-m) переменных – свободными (небазисными), а соответствующие результирующие значения переменных называют базисным решением.</p>
            </p>


            <p><strong><h2 class="theory-seva-h2">§4. Симплекс-метод.</h2><strong>
            <p class="theory-sevaT">Симплекс-метод позволяет эффективно найти оптимальное решение, избегая простой перебор всех возможных угловых точек. Основной принцип метода: вычисления начинаются с какого-то «стартового» базисного решения, а затем ведется поиск решений, «улучшающих» значение целевой функции. Это возможно только в том случае, если возрастание какой-то переменной приведет к увеличению значения функционала.</p>

            <p class="theory-sevaT">Необходимые условия для применения симплекс-метода:</p>

            <p class="theory-sevaT">1. Задача должна иметь каноническую форму.</p>
            <p class="theory-sevaT">2. У задачи должен быть явно выделенный базис.</p>

            <p class="theory-sevaT">Определение: Явно выделенным базисом будем называть вектора вида:</p>
            <p class="theory-sevaT">(..0100..)ᵀ, (..010..)ᵀ,(..0010..)ᵀ..., т.е. только одна координата вектора ненулевая и равна 1.</p>

            <p class="theory-sevaT">Замечание: Базисный вектор имеет размерность (m*1), где m – количество уравнений в системе ограничений.</p>

            <p class="theory-sevaT">Для удобства вычислений и наглядности обычно пользуются симплекс-таблицами:</p>
            <div class="image-container">
            <img src="/static/assets/images/1_3.png">
            </div>
            <ul class="theory-sevaT">
                <li>В первой строке указывают «наименование» всех переменных.</li>
                <li>В первом столбце указывают номера базисных переменных, а в последней ячейке – букву Z (это строка функционала).</li>
                <li>В «середине таблицы» указывают коэффициенты матрицы ограничений — aij.</li>
                <li>Последний столбец – вектор правых частей соответствующих уравнений системы ограничений.</li>
                <li>Крайняя правая ячейка – значение целевой функции. На первой итерации ее полагают равной 0.</li>
            </ul>

            <p class="theory-sevaT">Замечание: Базис – переменные, коэффициенты в матрице ограничений при которых образуют базисные вектора.</p>

            <p class="theory-sevaT">Замечание: Если ограничения в исходной задаче представлены неравенствами вида ≤, то при приведении задачи к канонической форме, введенные дополнительные переменные образуют начальное базисное решение.</p>

            <p class="theory-sevaT">Замечание: Коэффициенты в строке функционала берутся со знаком “-”.</p>

            <h2 class="theory-seva-h2"><strong>Алгоритм симплекс-метода:</h2></strong>

            <p class="theory-sevaT">1. Выбираем переменную, которую будем вводить в базис. Это делается в соответствии с указанным ранее принципом: мы должны выбрать переменную, возрастание которой приведет к росту функционала. Выбор происходит по следующему правилу:</p>

            <ul class="theory-sevaT">
                <li>Если задача на минимум – выбираем максимальный положительный элемент в последней строке.</li>
                <li>Если задача на максимум – выбираем минимальный отрицательный.</li>
            </ul>

            <p class="theory-sevaT">Такой выбор, действительно, соответствует упомянутому выше принципу: если задача на минимум, то чем большее число вычитаем – тем быстрее убывает функционал; для максимума наоборот – чем большее число добавляем, тем быстрее функционал растет.</p>

            <p class="theory-sevaT">Замечание: Хотя мы и берем минимальное отрицательное число в задаче на максимум, этот коэффициент показывает направление роста функционала, т.к. строка функционала в симплекс-таблице взята со знаком “-”. Аналогичная ситуация с минимизацией.</p>

            <p class="theory-sevaT">Определение: Столбец симплекс-таблицы, отвечающий выбранному коэффициенту, называется ведущим столбцом.</p>

            <p class="theory-sevaT">2. Выбираем переменную, которую будем вводить в базис. Для этого нужно определить, какая из базисных переменных быстрее всего обратится в нуль при росте новой базисной переменной. Алгебраически это делается так:</p>

            <ul class="theory-sevaT">
                <li>Вектор правых частей почленно делится на ведущий столбец</li>
                <li>Среди полученных значений выбирают минимальное положительное (отрицательные и нулевые ответы не рассматривают)</li>
            </ul>

            <p class="theory-sevaT">Определение: Такая строка называется ведущей строкой и отвечает переменной, которую нужно вывести из базиса.</p>

            <p class="theory-sevaT">Замечание: Фактически, мы выражаем старые базисные переменные из каждого уравнения системы ограничений через остальные переменные и смотрим, в каком уравнении возрастание новой базисной переменной быстрее всего даст 0. Попадание в такую ситуацию означает, что мы «наткнулись» на новую вершину. Именно поэтому нулевые и отрицательные элементы не рассматриваются, т.к. получение такого результата означает, что выбор такой новой базисной переменной будет уводить нас из области, вне которой решений не существует.</p>

            <p class="theory-sevaT">3. Ищем элемент, стоящий на пересечении ведущих строки и столбца.</p>

            <p class="theory-sevaT">Определение: Такой элемент называется ведущим элементом.</p>

            <p class="theory-sevaT">4. Вместо исключаемой переменной в первом столбце (с названиями базисных переменных) записываем название переменной, которую мы вводим в базис.</p>

            <p class="theory-sevaT">5. Далее начинается процесс вычисления нового базисного решения. Он происходит с помощью метода Жордана-Гаусса.</p>

            <ul class="theory-sevaT">
                <li>Новая Ведущая строка = Старая ведущая строка / Ведущий элемент</li>
                <li>Новая строка = Новая строка – Коэффициент строки в ведущем столбце * Новая Ведущая строка</li>
            </ul>

            <p class="theory-sevaT">Замечание: Преобразование такого вида направлено на введение выбранной переменной в базис, т.е. представление ведущего столбца в виде базисного вектора.</p>

            <p class="theory-sevaT">6. После этого проверяем условие оптимальности. Если полученное решение неоптимально – повторяем весь процесс снова.</p>
            </p>


            <p><strong><h2 class="theory-seva-h2">§5. Интерпретация результата работы симплекс-метода.</strong></h2>
            <h2 class="theory-seva-h2"><strong>1. Оптимальность</strong></h2>

            <p class="theory-sevaT">Условие оптимальности полученного решения:<p>

            <p class="theory-sevaT">Если задача на максимум – в строке функционала нет отрицательных коэффициентов (т.е. при любом изменении переменных значение итогового функционала расти не будет).<p>
            <p class="theory-sevaT">Если задача на минимум – в строке функционала нет положительных коэффициентов (т.е. при любом изменении переменных значение итогового функционала уменьшаться не будет).<p>

            <h2 class="theory-seva-h2"><strong>2. Неограниченность функционала</strong></h2>

            <p class="theory-sevaT">Однако, стоит отметить, что заданный функционал может не и достигать максимума/минимума в заданной области. Алгебраический признак этого можно сформулировать следующим образом:</p>

            <p class="theory-sevaT">При выборе ведущей строки (исключаемой переменной) результат почленного деления вектора правых частей на ведущий столбец содержит только нулевые и отрицательные значения.</p>

            <p class="theory-sevaT">Фактически, это значит, что какой бы рост мы не задавали новой базисной переменной, мы никогда не найдем новую вершину. А значит, наша функция не ограничена на множестве допустимых решений.</p>

            <h2 class="theory-seva-h2"><strong>3. Альтернативные решения</strong></h2>

            <p class="theory-sevaT">При нахождении оптимального решения возможен еще один вариант – есть альтернативные решения (другая угловая точка, дающая то же самое значение функционала).</p>

            <p class="theory-sevaT">Алгебраический признак существования альтернативы:</p>

            <p class="theory-sevaT">После достижения оптимального решения имеются нулевые коэффициенты при свободных переменных в строке функционала.</p>

            <p class="theory-sevaT">Это значит, что при росте соответствующей переменной с нулевым коэффициентом значение функционала не изменится и новое базисное решение будет также давать оптимум функционала.</p>
        </body>
        </html>
    </div>
    

</div>

